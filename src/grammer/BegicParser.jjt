/** オプション */
options
{
  /* parserをfor文などで繰り返し使うならfalseにする */
  STATIC = false;
  MULTI = true;
  VISITOR = true;
  UNICODE_INPUT = true;
}

/** Parserクラスの定義 */
PARSER_BEGIN(BegicParser)
package jp.tolz.begic.prototype.interpreter.parser;

import java.util.ArrayList;

import jp.tolz.begic.prototype.interpreter.values.*;
import jp.tolz.begic.prototype.interpreter.values.base.*;

public class BegicParser{
	private void log(String info) {
		System.out.println("[BegicParser]" + info);
	}
}

PARSER_END(BegicParser)

/** ここまでがParserクラスの定義 */
/** 以下は文法の定義 */

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* OPERATORS */

TOKEN :
{
  < EQ : "==" >
| < NEQ : "!=" >
| < ASSIGN : "=" >
| < EXCHANGE : "<->" >
| < GT : ">" >
| < LT : "<" >
| < LE: "<=" >
| < GE: ">=" >
| < NOT : "not" >
| < QUESTION : "?" >
| < OR : "or" >
| < AND : "and" >
| < PLUS : "+" >
| < MINUS : "-" >
| < STAR : "*" >
| < SLASH : "/" >
| < POWER : "^" >
| < MOD : "mod" >
}


/* ----- COMMAND ----- */

TOKEN :
{
  < BCOMMAND :
    "line"
  | "circle"
  | "box"
  | "print"
  | "write"
  | "input" >
}

/* ----- STATEMENTS ----- */
TOKEN :
{
  < IF : "if" >
| < ELSIF : "elsif" >
| < ELSE : "else" >
| < WHILE : "while" >
| < LOOP : "loop" >
| < FOR : "for" >
| < BREAK : "break" >
| < NEXT : "next" >
| < TO : "to" >
| < STEP : "step" >
| < DO : "do" >
| < END : "end" >
| < CALL : "call" >
}

/* FUNCTION */

TOKEN :
{
  < BFUNCTION :
  "sin"
| "cos"
| "tan"
| "log"
| "sinh"
| "cosh"
| "tanh"
| "sqrt"
| "exp" >
}


/* ----- COMMENTS ----- */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* ----- VALUES ----- */

TOKEN :
{
  < STRING:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
| < FLOAT : (["0"-"9"])+("."(["0"-"9"])+)* >
| < COLOR :
      ( "#"(["0"-"9"]) {6}
      | "red"
      | "blue"
      | "yellow"
      | "green"
      | "white"
      | "black"
      )
  >
| < BOOLEAN : "true" | "false" >
| < IDENTIFIER : (["a"-"z","A"-"Z"])+ (["0"-"9"])* >
}


SimpleNode Program() :
{ Token prog = null; }
{
  (    (         Command()
      |  LOOKAHEAD(2) Assingment()
      |  LOOKAHEAD(3) Operation()
      |  Call()
      |  IfStatement()
      |  LoopStatement()
      |  WhileStatement()
      |  ForStatement()
    ) (";")?
  )*
  {
	return jjtThis;
  }
}

// いまのところふつうの引数の形式にする。括弧の省略は可能。
void Command() :
{ Token t = null; }
{
  LOOKAHEAD(2) t = < BCOMMAND >  Args() { jjtThis.jjtSetValue(t.image); }
| t = < BCOMMAND > { jjtThis.jjtSetValue(t.image); }
}

void Args() :
{}
{
  LOOKAHEAD(2) "(" ( Operation() ("," Operation())* )* ")"
| Operation() ("," Operation())*
}

void Call() :
{}
{
  < CALL > Operation()
}

void IfStatement() :
{}
{
  < IF > Operation() Block() ( < ELSIF > Operation() Block() )* ( < ELSE > Block() )?
}

void LoopStatement() :
{}
{
  < LOOP > Block()
}

void WhileStatement() :
{}
{
  < WHILE > Operation() Block()
}

void ForStatement() :
{ Token t = null; }
{
  < FOR > t = < IDENTIFIER > < ASSIGN > Operation() < TO > Operation() < STEP > Operation() Block()
  {
    jjtThis.jjtSetValue(t.image);
  }
}

void Block() :
{}
{
  ("{"|"do")
  ((
       Command()
    |  LOOKAHEAD(2) Assingment()
    |  LOOKAHEAD(3) Operation()
    |  Call()
    |  Break()
    |  Next()
    |  IfStatement()
    |  LoopStatement()
    |  WhileStatement()
    |  ForStatement()
  ) (";")?)*
  ("}"|"end")
}

void Break() :
{}
{
  < BREAK >
}

void Next() :
{}
{
  < NEXT >
}

void Assingment() :
{}
{
  Identifier() < ASSIGN > Operation()
}

void Operation() :
{}
{
  OrOp() 
}

void OrOp() :
{}
{
  AndOp() ( < OR > AndOp() )*
}

void AndOp() :
{}
{
  NotOp() ( < AND > NotOp() )*
}

void NotOp() :
{}
{
  ( < NOT > )* CompOp()
}

void CompOp() :
{}
{
  AddMnsOp() ( Comp() AddMnsOp() )*
}

void Comp() :
{}
{
  < EQ > | < LT > | < GT > | < LE > | < GE > | < NEQ >
}

void AddMnsOp() :
{}
{
  MulDivOp() ( AddMns() MulDivOp() )*
}

void AddMns() :
{}
{
  < PLUS > 
| < MINUS >
}


void MulDivOp() :
{}
{
  ModPowOp() ( MulDiv() ModPowOp() )*
}

void MulDiv() :
{}
{
  < STAR >
| < SLASH > 
}

void ModPowOp() :
{}
{
  Expression() ( ModPow() Expression())*
}

void ModPow() :
{}
{
  < MOD >
| < POWER >
}

void Expression() :
{}
{
  LOOKAHEAD(3) Block()
| LOOKAHEAD(2) Identifier()
| Float()
| String()
| Color()
| Boolean()
| List()
| Hash()
| ListHashFactor()
| "(" Operation() ")"
}

void List() :
{}
{
  "[" ( Operation() ("," Operation())*)* "]"
}

void Hash() :
{}
{
  "{" Operation() ":" Operation() (","  Operation() ":" Operation() )* "}"
}

void ListHashFactor() :
{}
{
  Identifier() "[" Operation() "]"
}

void Identifier() :
{ Token t = null; }
{
  t = < IDENTIFIER > { jjtThis.jjtSetValue(t.image); }
}

void Boolean() :
{ Token t = null; }
{
  t = < BOOLEAN > { jjtThis.jjtSetValue(t.image); }
}

void Float() :
{ Token t = null; }
{
  t = < FLOAT > { jjtThis.jjtSetValue(t.image); }  
}

void String() :
{ Token t = null; }
{
  t = < STRING > { jjtThis.jjtSetValue(t.image); }
}

void Color() :
{ Token t = null; }
{
  t = < COLOR > { jjtThis.jjtSetValue(t.image); }  
}