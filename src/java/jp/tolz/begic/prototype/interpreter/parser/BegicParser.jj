/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. BegicParser.jj */
/*@egen*//** \u30aa\u30d7\u30b7\u30e7\u30f3 */
options
{
  /* parser\u3092for\u6587\u306a\u3069\u3067\u7e70\u308a\u8fd4\u3057\u4f7f\u3046\u306a\u3089false\u306b\u3059\u308b */
  STATIC = false;
               
                 
  UNICODE_INPUT = true;
}

/** Parser\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9 */
PARSER_BEGIN(BegicParser)
package jp.tolz.begic.prototype.interpreter.parser;

public class BegicParser/*@bgen(jjtree)*/implements BegicParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTBegicParserState jjtree = new JJTBegicParserState();

/*@egen*/
  /* \u3053\u3053\u306b\uff0c\u666e\u901a\u306eJava\u30af\u30e9\u30b9\u306e\u3088\u3046\u306b\u30e1\u30bd\u30c3\u30c9\u3092\u5b9a\u7fa9\u3067\u304d\u308b\u3063\u307d\u3044 */
}

PARSER_END(BegicParser)

/** \u3053\u3053\u307e\u3067\u304cParser\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9 */
/** \u4ee5\u4e0b\u306f\u6587\u6cd5\u306e\u5b9a\u7fa9 */

/** \u7121\u8996\u3059\u308b\u6587\u5b57\u3092\u5b9a\u7fa9 */
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

/** \u51fa\u73fe\u3059\u308b\u30c8\u30fc\u30af\u30f3\u3092\u5b9a\u7fa9 */
TOKEN :
{
  < INTEGER : (["0"-"9"])+ >
| < PLUS : "+" >
| < TIMES : "*" >
}

//\u69cb\u6587\u306e\u5b9a\u7fa9
int term() :
{/*@bgen(jjtree) term */
  ASTterm jjtn000 = new ASTterm(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  int a = 0, b;
}
{/*@bgen(jjtree) term */
  try {
/*@egen*/
  b = expr() (< PLUS > a = integer())* ";"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return a + b;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

int expr() :
{/*@bgen(jjtree) expr */
  ASTexpr jjtn000 = new ASTexpr(JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  int a = 1, b;
}
{/*@bgen(jjtree) expr */
  try {
/*@egen*/
  b = integer() (< TIMES > a = integer())*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return a * b;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

int integer() :
{/*@bgen(jjtree) integer */
  ASTinteger jjtn000 = new ASTinteger(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token a;
}
{/*@bgen(jjtree) integer */
        try {
/*@egen*/
	a = < INTEGER >/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ {
	  return Integer.valueOf(a.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}